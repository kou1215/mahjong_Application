<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mahjong Simulator</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
  <style>
    /* ç°¡æ˜“ãƒãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆCSS (å¿…è¦ã«å¿œã˜ã¦styles.cssã¸ç§»å‹•ã—ã¦ãã ã•ã„) */
    #mahjong-stadium {
      display: flex;
      flex-direction: column;
      height: 95vh;
      justify-content: space-between;
      padding: 10px;
      background-color: #2c5d3f;
      color: white;
    }
    #opponents-row {
      display: flex;
      justify-content: space-around;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    .opponent-area {
      text-align: center;
      background: rgba(0,0,0,0.2);
      padding: 10px;
      border-radius: 8px;
    }
    .opponent-tile {
      width: 32px; /* ç›¸æ‰‹ã®ç‰Œã¯å°ã•ã */
      height: auto;
    }
    #center-table {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 15px;
      padding: 20px;
    }
    #game-info {
      display: flex;
      align-items: center;
      gap: 20px;
      background: rgba(0,0,0,0.4);
      padding: 10px 20px;
      border-radius: 10px;
      margin-bottom: 20px;
    }
    .center-discard-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 5px 0;
    }
    #my-area {
      text-align: center;
      background: rgba(0,0,0,0.3);
      padding: 20px;
      border-radius: 10px;
    }
    .tsumo-tile {
      margin-left: 20px !important;
    }
  </style>
</head>
<body>
  <div id="mahjong-stadium">
    <div id="game-info">
      <div id="turn-indicator">æ‰‹ç•ª: Player <span id="turn-player">{{ current_turn if hands_view else 0 }}</span></div>
      <div id="phase-indicator">çŠ¶æ…‹: <span id="phase-text">{{ phase if hands_view else 'discard' }}</span></div>
      <div id="dora-indicator-area">
        ãƒ‰ãƒ©è¡¨ç¤ºç‰Œ:
        {% if hands_view and dora_indicator %}
          <img id="dora-indicator-img" class="tile dora-tile" src="/static/tiles/{{ dora_indicator }}.png" alt="{{ dora_indicator }}" style="width: 40px;" onerror="handleImageError(this, '{{ dora_indicator }}')">
        {% else %}
          <span id="dora-indicator-img"></span>
        {% endif %}
      </div>
      <div id="remaining-draws">æ®‹ã‚Šãƒ„ãƒ¢å›æ•°: <span id="remaining-draws-count">{{ remaining_draws if hands_view else '' }}</span></div>
      <form action="/reset" method="get" style="display:inline; margin-left:20px;">
        <button type="submit">æ–°è¦å¯¾å±€ï¼ˆãƒªã‚»ãƒƒãƒˆï¼‰</button>
      </form>
    </div>

    <div id="opponents-row">
      {% if hands_view %}
        <div class="opponent-area" id="opponent-3">
          <div class="opponent-label">Player 3</div>
          <div id="melds-display-area-3" style="margin-bottom:6px;"></div>
          <div class="tiles-row opponent-tiles" id="tiles-row-3">
            {% for t in hands_view[3].tiles %}
              <img class="tile opponent-tile clickable" data-player="3" data-index="{{ loop.index0 }}" src="{{ url_for('static', filename='tiles/' + t + '.png') }}" alt="{{ t }}" onerror="handleImageError(this, '{{ t }}')">
            {% endfor %}
          </div>
          <div class="discards" id="discards-3"></div>
        </div>
        <div class="opponent-area" id="opponent-2">
          <div class="opponent-label">Player 2</div>
          <div id="melds-display-area-2" style="margin-bottom:6px;"></div>
          <div class="tiles-row opponent-tiles" id="tiles-row-2">
            {% for t in hands_view[2].tiles %}
              <img class="tile opponent-tile clickable" data-player="2" data-index="{{ loop.index0 }}" src="{{ url_for('static', filename='tiles/' + t + '.png') }}" alt="{{ t }}" onerror="handleImageError(this, '{{ t }}')">
            {% endfor %}
          </div>
          <div class="discards" id="discards-2"></div>
        </div>
        <div class="opponent-area" id="opponent-1">
          <div class="opponent-label">Player 1</div>
          <div id="melds-display-area-1" style="margin-bottom:6px;"></div>
          <div class="tiles-row opponent-tiles" id="tiles-row-1">
            {% for t in hands_view[1].tiles %}
              <img class="tile opponent-tile clickable" data-player="1" data-index="{{ loop.index0 }}" src="{{ url_for('static', filename='tiles/' + t + '.png') }}" alt="{{ t }}" onerror="handleImageError(this, '{{ t }}')">
            {% endfor %}
          </div>
          <div class="discards" id="discards-1"></div>
        </div>
      {% endif %}
    </div>

    <div id="center-table">
      <div id="gameover-message" style="display:none;">æµå±€ï¼ˆå±±ç‰ŒãŒãªããªã‚Šã¾ã—ãŸï¼‰</div>
    </div>

    <div id="my-area">
      {# Template block #}
      {% if hands_view %}
          {% if hands_view[0] %}
             <div class="my-label">ã‚ãªãŸ (Player 0)</div>
          <div class="discards" id="discards-0"></div>
          <div id="melds-display-area" style="margin-bottom:12px;"></div>
          <div id="agari-tiles-area" style="margin-bottom:10px;"></div>
          <div class="tiles-row my-tiles" id="tiles-row-0">
            {% for t in hands_view[0].tiles %}
              <img class="tile clickable" data-player="0" data-index="{{ loop.index0 }}" src="{{ url_for('static', filename='tiles/' + t + '.png') }}" alt="{{ t }}">
            {% endfor %}
          </div>
          <button type="button" id="riichi-btn" style="display: {% if can_riichi %}inline-block{% else %}none{% endif %}; background-color: #9c27b0; color: white; margin-right: 10px; margin-top: 8px; margin-bottom: 8px;" onclick="toggleRiichi()">ğŸ”¥ ãƒªãƒ¼ãƒ</button>
          <button type="button" id="agari-btn" onclick="checkAgari()">ğŸ¯ ã‚¢ã‚¬ã‚Šåˆ¤å®š</button>
          <div id="available-calls-area" style="margin-top:12px;"></div>
        {% endif %}
      {% endif %}
    </div>
  </div>

 <script>
      // ãƒªãƒ¼ãƒãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ç®¡ç†
      let riichiMode = false;

      // ãƒªãƒ¼ãƒãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ã®æŒ™å‹•
      function toggleRiichi() {
        const riichiBtn = document.getElementById('riichi-btn');
        riichiMode = !riichiMode;
        if (riichiMode) {
          riichiBtn.style.backgroundColor = '#ff9800';
          riichiBtn.innerText = 'ãƒªãƒ¼ãƒå®£è¨€ä¸­ï¼';
        } else {
          riichiBtn.style.backgroundColor = '#9c27b0';
          riichiBtn.innerText = 'ğŸ”¥ ãƒªãƒ¼ãƒ';
        }
      }
    function handleImageError(element, tileName) {
      if (element.src.endsWith('.png')) {
        element.onerror = null;
        element.src = '/static/tiles/' + tileName + '.svg';
      }
    }

    // Jinja2ã®å‡ºåŠ›ã‚’ä¸€åº¦æ–‡å­—åˆ—ã¨ã—ã¦å—ã‘å–ã‚Šã€JSã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ãƒ‘ãƒ¼ã‚¹ï¼ˆæ³¢ç·šå¯¾ç­–ï¼‰
    const handsView = JSON.parse('{{ hands_view | tojson | safe if hands_view else "null" }}');
    const agariTilesView = JSON.parse('{{ agari_tiles_view | tojson | safe if agari_tiles_view else "null" }}');
    const pendingCalls = JSON.parse('{{ pending_calls | tojson | safe if pending_calls else "[]" }}');
    const lastDiscarded = JSON.parse('{{ last_discarded | tojson | safe if last_discarded else "null" }}');
    const initialIsRiichi = JSON.parse('{{ is_riichi | tojson | safe if is_riichi is defined else "[false, false, false, false]" }}');
    const initialIppatsuEligible = JSON.parse('{{ ippatsu_eligible | tojson | safe if ippatsu_eligible is defined else "[false, false, false, false]" }}');
    const initialCanRiichi = JSON.parse('{{ can_riichi | tojson | safe if can_riichi is defined else "false" }}');
  
  // æ•°å€¤ã¨æ–‡å­—åˆ—ã‚‚å¼•ç”¨ç¬¦ã§å›²ã‚€ã“ã¨ã§JSã®æ–‡æ³•ã‚¨ãƒ©ãƒ¼ã‚’é˜²ã
    let currentTurn = parseInt('{{ current_turn if current_turn is defined else 0 }}');
    let gamePhase = '{{ phase if phase is defined else "discard" }}';

    const discards = handsView ? handsView.map(h => h.discards) : [[], [], [], []];
    const initialMelds = handsView ? handsView.map(h => h.melds) : [[], [], [], []];
    const initialAgariTiles = agariTilesView || [[], [], [], []];
    const initialPendingCalls = pendingCalls || [];
    const initialLastDiscarded = lastDiscarded || null;
    let lastDrawnTile = null;
    window.player0_draw = null;
    let is_riichi = initialIsRiichi;
    let ippatsu_eligible = initialIppatsuEligible;
    let can_riichi = initialCanRiichi;

    function updatePlayerStatusBadges(isRiichiList, ippatsuList) {
      for (let p = 0; p < 4; p++) {
        const labelElem = (p === 0)
          ? document.querySelector('.my-label')
          : document.querySelector('#opponent-' + p + ' .opponent-label');
        if (!labelElem) continue;

        const baseText = (p === 0) ? 'ã‚ãªãŸ (Player 0)' : ('Player ' + p);
        let html = baseText;
        if (isRiichiList && isRiichiList[p]) {
          html += ' <span class="status-badge riichi-badge">ãƒªãƒ¼ãƒ</span>';
        }
        if (ippatsuList && ippatsuList[p]) {
          html += ' <span class="status-badge ippatsu-badge">ä¸€ç™ºæœ‰åŠ¹ä¸­</span>';
        }
        labelElem.innerHTML = html;
      }
    }

    function setTileClickHandlers() {
            // ãƒªãƒ¼ãƒãƒœã‚¿ãƒ³ã®è¡¨ç¤ºãƒ»çŠ¶æ…‹
            const riichiBtn = document.getElementById('riichi-btn');
            if (typeof can_riichi !== 'undefined' && riichiBtn) {
              if (can_riichi) {
                riichiBtn.style.display = '';
              } else {
                riichiBtn.style.display = 'none';
                riichiMode = false;
                riichiBtn.classList.remove('active');
              }
            }
      // ãƒªãƒ¼ãƒçŠ¶æ…‹ã‹ã¤è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ãªã‚‰ã‚¯ãƒªãƒƒã‚¯ä¸å¯
      const isPlayer0Riichi = (typeof is_riichi !== 'undefined') ? is_riichi[0] : false;
      const isPlayer0Turn = (currentTurn === 0);

      document.querySelectorAll('img[data-player][data-index]').forEach(img => {
        const player = parseInt(img.getAttribute('data-player'));
        // ãƒªãƒ¼ãƒçŠ¶æ…‹ã‹ã¤è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ãªã‚‰ã‚¯ãƒªãƒƒã‚¯ä¸å¯
        const isActive = (gamePhase !== 'call_wait') && (player === currentTurn) && !(isPlayer0Riichi && isPlayer0Turn);
        img.classList.toggle('clickable', isActive);
        img.style.opacity = isActive ? '1' : '0.72';
        img.title = isActive ? 'æ‰“ç‰Œã§ãã¾ã™' : ('ç¾åœ¨ã®æ‰‹ç•ªã¯ Player ' + currentTurn + ' ã§ã™');

        img.onclick = function() {
          if (!isActive) return;
          if (gamePhase === 'call_wait') {
            alert('é³´ãåˆ¤å®šä¸­ã§ã™ã€‚ãƒãƒ³/ãƒãƒ¼/ã‚¹ãƒ«ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
            return;
          }
          const player = parseInt(this.getAttribute('data-player'));
          const idx = parseInt(this.getAttribute('data-index'));
          if (player !== currentTurn) {
            alert('ç¾åœ¨ã®æ‰‹ç•ªã¯ Player ' + currentTurn + ' ã§ã™ã€‚');
            return;
          }
          discardTile(player, idx, riichiMode);
        };
      });
    }

    function disableTileClickHandlers() {
      document.querySelectorAll('img[data-player][data-index]').forEach(img => {
        img.onclick = null;
        img.classList.remove('clickable');
        img.style.opacity = '0.72';
      });
    }

    // ã‚¢ã‚¬ã‚Šå½¢åˆ¤å®šã§ãƒœã‚¿ãƒ³è‰²ã‚’æ›´æ–°
    function updateAgariButton() {
      const button = document.getElementById('agari-btn'); // IDã‚’æ­£ã—ãä¿®æ­£
      if (!button) return;
      
      // Player 0 ã®ã‚·ãƒ£ãƒ³ãƒ†ãƒ³æ•°ã‚’å–å¾—
      const shanten = window.shantenValues ? window.shantenValues[0] : null;
      
      if (shanten === -1) {
        // ã‚¢ã‚¬ã‚Šå½¢ï¼šãƒœã‚¿ãƒ³ã‚’ç›®ç«‹ã¤è‰²ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ç³»ï¼‰ã«å¤‰æ›´
        button.style.background = '#FF6B35';
        button.title = 'ã‚¢ã‚¬ã‚Šå½¢ã§ã™ï¼';
      } else if (shanten === 0) {
        // ãƒ†ãƒ³ãƒ‘ã‚¤ï¼šãƒœã‚¿ãƒ³ã‚’æ³¨æ„è‰²ã«
        button.style.background = '#FFB703';
        button.title = 'ãƒ†ãƒ³ãƒ‘ã‚¤ã—ã¦ã„ã¾ã™';
      } else {
        // é€šå¸¸çŠ¶æ…‹ï¼šç·‘
        button.style.background = '#4CAF50';
        button.title = '';
      }
    }

    // èª¤ã£ã¦æ¶ˆãˆã¦ã„ãŸ discardTile é–¢æ•°ã‚’å¾©å…ƒãƒ»ä¿®æ­£
    async function discardTile(playerId, idx) {
      const formData = new FormData();
      formData.append('player_id', playerId);
      formData.append('discard_index', idx);
      if (riichiMode) formData.append('declare_riichi', 'true');
      const res = await fetch('/discard', { method: 'POST', body: formData });
      if (!res.ok) {
        alert('ã‚¨ãƒ©ãƒ¼: ' + (await res.text()));
        return;
      }
      const data = await res.json();
      // ãƒ‡ãƒãƒƒã‚°ç”¨: ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰è¿”ã£ã¦ããŸis_riichiãƒªã‚¹ãƒˆã‚’å‡ºåŠ›
      console.log("--- Server Response: is_riichi List ---");
      console.table(data.is_riichi);

      is_riichi = data.is_riichi || is_riichi;
      ippatsu_eligible = data.ippatsu_eligible || ippatsu_eligible;
      can_riichi = (typeof data.can_riichi !== 'undefined') ? data.can_riichi : can_riichi;
      updatePlayerStatusBadges(is_riichi, ippatsu_eligible);

      // ãƒªãƒ¼ãƒãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ¶å¾¡
      const riichiBtn = document.getElementById('riichi-btn');
      if (riichiBtn && typeof data.can_riichi !== 'undefined') {
        if (data.can_riichi) {
          riichiBtn.style.display = 'inline-block';
        } else {
          riichiBtn.style.display = 'none';
          if (typeof isDeclaringRiichi !== 'undefined') {
            isDeclaringRiichi = false;
          }
          riichiBtn.style.backgroundColor = '#9c27b0';
          riichiBtn.innerText = 'ğŸ”¥ ãƒªãƒ¼ãƒ';
        }
      }

      currentTurn = data.current_turn;
      gamePhase = data.phase;
      window.player0_draw = data.next_draw;
      window.shantenValues = data.shanten_list;
      lastDrawnTile = data.next_draw;

      // if there are available calls show UI
      if (data.available_calls && data.available_calls.length > 0) {
        renderAvailableCalls(data.available_calls, data.discarded_tile);
      } else {
        const area = document.getElementById('available-calls-area');
        if (area) area.innerHTML = '';
      }

      updateHands(data.hands, data.shanten_list);
      updateDiscards(data, data.auto_log);
      displayAllMelds(data.melds || [[], [], [], []]);
      renderAgariTiles((data.agari_tiles && data.agari_tiles[0]) ? data.agari_tiles[0] : []);
      refreshTurnInfo();

      // update UI
      updateAgariButton();

      const doraImgArea = document.getElementById('dora-indicator-area');
      if (doraImgArea) {
        let doraImg = document.getElementById('dora-indicator-img');
        if (doraImg) {
          if (data.dora_indicator) {
            doraImg.src = '/static/tiles/' + data.dora_indicator + '.png';
            doraImg.alt = data.dora_indicator;
            doraImg.onerror = function() { handleImageError(this, data.dora_indicator); };
          } else {
            doraImg.src = ''; doraImg.alt = '';
          }
        } else if (data.dora_indicator) {
          doraImg = document.createElement('img');
          doraImg.id = 'dora-indicator-img';
          doraImg.className = 'tile dora-tile';
          doraImg.style.width = '40px';
          doraImg.src = '/static/tiles/' + data.dora_indicator + '.png';
          doraImg.alt = data.dora_indicator;
          doraImg.onerror = function() { handleImageError(this, data.dora_indicator); };
          doraImgArea.appendChild(doraImg);
        }
      }

      if (typeof data.remaining_draws !== 'undefined') {
        const drawsElem = document.getElementById('remaining_draws-count');
        if (drawsElem) drawsElem.textContent = data.remaining_draws;
      }

      if (data.is_game_over) {
        document.getElementById('gameover-message').style.display = 'block';
        disableTileClickHandlers();
      } else {
        setTileClickHandlers();
      }
    }

    function refreshTurnInfo() {
      const turnElem = document.getElementById('turn-player');
      const phaseElem = document.getElementById('phase-text');
      if (turnElem) turnElem.textContent = currentTurn;
      if (phaseElem) phaseElem.textContent = gamePhase;
    }

    function renderAvailableCalls(availableCalls, discardedTile) {
      const area = document.getElementById('available-calls-area');
      area.innerHTML = '';
      const title = document.createElement('div');
      title.innerText = 'é³´ãå¯èƒ½: æœ€è¿‘ã®æ¨ã¦ç‰Œ ' + (discardedTile || '');
      area.appendChild(title);

      availableCalls.forEach(entry => {
        const pid = entry.player_id;
        const calls = entry.calls;
        const box = document.createElement('div');
        box.style.margin = '6px 0';
        box.style.padding = '6px';
        box.style.background = 'rgba(255,255,255,0.05)';
        box.style.borderRadius = '6px';
        const label = document.createElement('strong');
        label.innerText = 'Player ' + pid + ':';
        box.appendChild(label);

        // Pong
        if (calls.can_pong) {
          const b = document.createElement('button');
          b.innerText = 'ãƒãƒ³';
          b.onclick = () => applyCall(pid, 'pong', [discardedTile]);
          box.appendChild(b);
        }

        // Chow: show combos if available
        if (calls.can_chow && entry.chow_combos && entry.chow_combos.length > 0) {
          entry.chow_combos.forEach(combo => {
            const cb = document.createElement('button');
            cb.innerText = 'ãƒãƒ¼ ' + combo.join(' ');
            cb.onclick = () => applyCall(pid, 'chow', combo);
            box.appendChild(cb);
          });
        }

        // Kan
        if (calls.can_kan) {
          const kb = document.createElement('button');
          kb.innerText = 'ã‚«ãƒ³';
          kb.onclick = () => applyCall(pid, 'kan', [discardedTile]);
          box.appendChild(kb);
        }

        // Ron
        if (calls.can_ron) {
          const rb = document.createElement('button');
          rb.innerText = 'ãƒ­ãƒ³';
          rb.onclick = () => applyCall(pid, 'ron', [discardedTile]);
          box.appendChild(rb);
        }

        // Pass
        const pb = document.createElement('button');
        pb.innerText = 'ã‚¹ãƒ«ãƒ¼';
        pb.onclick = () => applyCall(pid, 'pass', []);
        box.appendChild(pb);

        area.appendChild(box);
      });
    }

    async function applyCall(player_id, action, tiles) {
      const res = await fetch('/apply_call', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ player_id: player_id, action: action, tiles: tiles })
      });
      if (!res.ok) {
        alert('é³´ãå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ' + (await res.text()));
        return;
      }
      const data = await res.json();

      is_riichi = data.is_riichi || is_riichi;
      ippatsu_eligible = data.ippatsu_eligible || ippatsu_eligible;
      can_riichi = (typeof data.can_riichi !== 'undefined') ? data.can_riichi : can_riichi;
      updatePlayerStatusBadges(is_riichi, ippatsu_eligible);

      if (action === 'ron' || data.agari) {
        showAgariResult({
          agari: !!data.agari,
          value: data.value,
          player_id: data.player_id,
          win_tile: data.win_tile,
          is_tsumo: false,
          ura_dora_indicator: data.ura_dora_indicator,
        });
      }

      currentTurn = data.current_turn;
      gamePhase = data.phase;
      window.shantenValues = data.shanten_list;
      window.player0_draw = data.next_draw;
      lastDrawnTile = data.next_draw;
      updateHands(data.hands, data.shanten_list);
      displayAllMelds(data.melds || [[], [], [], []]);
      renderAgariTiles((data.agari_tiles && data.agari_tiles[0]) ? data.agari_tiles[0] : []);
      refreshTurnInfo();

      if (data.available_calls && data.available_calls.length > 0) {
        renderAvailableCalls(data.available_calls, data.discarded_tile);
      } else {
        const area = document.getElementById('available-calls-area');
        if (area) area.innerHTML = '';
      }

      if (typeof data.remaining_draws !== 'undefined') {
        const drawsElem = document.getElementById('remaining-draws-count');
        if (drawsElem) drawsElem.textContent = data.remaining_draws;
      }

      if (data.is_game_over) {
        document.getElementById('gameover-message').style.display = 'block';
        disableTileClickHandlers();
      } else {
        setTileClickHandlers();
      }
    }
    
    function renderMeldsForPlayer(playerId, melds) {
      const area = document.getElementById(playerId === 0 ? 'melds-display-area' : ('melds-display-area-' + playerId));
      if (!area) return;
      area.innerHTML = '';

      if (!melds || melds.length === 0) return;
      
      const title = document.createElement('div');
      title.innerText = 'å‰¯éœ²:';
      title.style.fontWeight = 'bold';
      title.style.marginBottom = '6px';
      title.style.fontSize = playerId === 0 ? '1em' : '0.85em';
      area.appendChild(title);
      
      melds.forEach(meld => {
        const box = document.createElement('div');
        box.style.display = 'flex';
        box.style.gap = '4px';
        box.style.marginBottom = '4px';
        
        meld.forEach(tile => {
          const img = document.createElement('img');
          img.className = 'tile';
          if (playerId === 0) {
            img.style.width = '40px';
            img.style.height = '50px';
          } else {
            img.style.width = '24px';
            img.style.height = '34px';
          }
          img.src = '/static/tiles/' + tile + '.png';
          img.alt = tile;
          img.onerror = function() { handleImageError(this, tile); };
          box.appendChild(img);
        });
        
        area.appendChild(box);
      });
    }

    function displayAllMelds(allMelds) {
      for (let p = 0; p < 4; p++) {
        renderMeldsForPlayer(p, (allMelds && allMelds[p]) ? allMelds[p] : []);
      }
    }

    function renderAgariTiles(agariTiles) {
      const area = document.getElementById('agari-tiles-area');
      if (!area) return;
      area.innerHTML = '';

      if (!agariTiles || agariTiles.length === 0) {
        return;
      }

      const title = document.createElement('div');
      title.innerText = 'å¾…ã¡ç‰Œ:';
      title.style.fontWeight = 'bold';
      title.style.marginBottom = '4px';
      area.appendChild(title);

      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.gap = '4px';
      row.style.justifyContent = 'center';

      agariTiles.forEach(tile => {
        const img = document.createElement('img');
        img.className = 'tile';
        img.style.width = '30px';
        img.style.height = '42px';
        img.src = '/static/tiles/' + tile + '.png';
        img.alt = tile;
        img.onerror = function() { handleImageError(this, tile); };
        row.appendChild(img);
      });

      area.appendChild(row);
    }

    async function checkAgari() {
      if (!lastDrawnTile) {
        alert('å¼•ã„ãŸç‰ŒãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }
      // ğŸ”´ ã“ã“ã‚’è¿½åŠ ï¼šä»Šã€ç”»é¢ä¸Šã§è‡ªåˆ†ï¼ˆPlayer 0ï¼‰ãŒãƒªãƒ¼ãƒã—ã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹
      const isActuallyRiichi = (is_riichi && is_riichi[0]) ? true : false;

      const res = await fetch('/check_agari', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          player_id: 0, 
          win_tile: lastDrawnTile, 
          is_tsumo: true,
          is_riichi: isActuallyRiichi // ğŸ”´ ã“ã“ã‚’è¿½åŠ ï¼šãƒªãƒ¼ãƒæƒ…å ±ã‚’ã‚µãƒ¼ãƒãƒ¼ã«é€ã‚‹
        })
      });
      if (!res.ok) {
        alert('ã‚¨ãƒ©ãƒ¼: ' + (await res.text()));
        return;
      }
      const data = await res.json();
      showAgariResult(data);
    }

    function showAgariResult(data) {
      if (!data.agari) { alert('ã‚¢ã‚¬ã£ã¦ã„ã¾ã›ã‚“'); return; }
      const value = data.value;
      if (!value || !value.valid) {
        alert('ã‚¢ã‚¬ãƒªãŒæˆç«‹ã—ã¦ã„ã¾ã›ã‚“: ' + (value ? value.error : 'Unknown error'));
        return;
      }
      let message = `â˜… ã‚¢ã‚¬ã‚ŠæˆåŠŸï¼\n\nç¿»æ•°: ${value.han}ç¿»\nç¬¦æ•°: ${value.fu}ç¬¦\nç‚¹æ•°: ${value.cost.main}ç‚¹ï¼ˆå…¨å“¡ã‹ã‚‰åˆè¨ˆ ${value.cost.total}ç‚¹ï¼‰\né™åº¦: ${value.limit}\nå½¹: ${value.yaku.join(', ')}`;
      message += `\nè£ãƒ‰ãƒ©è¡¨ç¤ºç‰Œ: ${data.ura_dora_indicator ? data.ura_dora_indicator : 'ãªã—'}`;
      alert(message);
    }

function updateHands(hands, shantenList) {
      console.log('updateHands called with:', hands.length, 'players');
      for (let p = 0; p < hands.length; ++p) {
        const row = document.getElementById('tiles-row-' + p);
        if (!row) {
          console.warn('tiles-row-' + p + ' not found');
          continue;
        }
        row.innerHTML = '';
        
        if (p === 0) {
          const hand = hands[0];
          const drawTile = window.player0_draw;
          
          if (hand.length === 14 && drawTile) {
            const drawIdx = hand.lastIndexOf(drawTile); 
            let normalTiles = [];
            let tsumoTileNode = null;
            hand.forEach((t, i) => {
              const img = document.createElement('img');
              img.className = 'tile clickable';
              img.setAttribute('data-player', 0);
              img.setAttribute('data-index', i);
              img.src = '/static/tiles/' + t + '.png';
              img.alt = t;
              img.onerror = function() { handleImageError(this, t); };
              if (i === drawIdx) {
                img.classList.add('tsumo-tile');
                tsumoTileNode = img;
              } else {
                normalTiles.push(img);
              }
            });
            normalTiles.forEach(node => row.appendChild(node));
            if (tsumoTileNode) row.appendChild(tsumoTileNode);
          } else {
            hand.forEach((t, i) => {
              const img = document.createElement('img');
              img.className = 'tile clickable';
              img.setAttribute('data-player', 0);
              img.setAttribute('data-index', i);
              img.src = '/static/tiles/' + t + '.png';
              img.alt = t;
              img.onerror = function() { handleImageError(this, t); };
              row.appendChild(img);
            });
          }
        } else {
          const hand = hands[p];
          for (let i = 0; i < hand.length; ++i) {
            const t = hand[i];
            const img = document.createElement('img');
            img.className = 'tile opponent-tile';
            img.setAttribute('data-player', p);
            img.setAttribute('data-index', i);
            img.src = '/static/tiles/' + t + '.png';
            img.alt = t;
            img.onerror = function() { handleImageError(this, t); };
            row.appendChild(img);
          }
        }
        
        const shantenSpan = document.getElementById('shanten-' + p);
        if (shantenSpan) {
          shantenSpan.innerText = (shantenList && shantenList[p] !== undefined) ? shantenList[p] : '?';
        }
      } // â† forãƒ«ãƒ¼ãƒ—ã®çµ‚ã‚ã‚Š
    }   

    function updateDiscards(data, auto_log) {
      if (data.discarded_tile !== undefined && data.discarded_tile !== null) {
        const discarder = (typeof data.discarder_id === 'number') ? data.discarder_id : 0;
        discards[discarder].push(data.discarded_tile);
        renderDiscards(discarder);
      }
      if (auto_log) {
        auto_log.forEach(log => {
          discards[log.player].push(log.discarded);
          renderDiscards(log.player);
        });
      }
    }

    function renderDiscards(player) {
      let div = document.getElementById('discards-' + player);
      if (!div) return;
      div.innerHTML = '';
      discards[player].forEach(t => {
        const img = document.createElement('img');
        img.src = '/static/tiles/' + t + '.png';
        img.alt = t;
        img.onerror = function() { handleImageError(this, t); };
        div.appendChild(img);
      });
    }

    // åˆæœŸåŒ–
    if (document.querySelectorAll('img[data-player][data-index]').length > 0) {
      setTileClickHandlers();
      updateAgariButton(); // åˆæœŸåŒ–æ™‚ã«ã‚‚ãƒœã‚¿ãƒ³ã®è‰²ã‚’åˆ¤å®šã•ã›ã‚‹
    }
    updatePlayerStatusBadges(is_riichi, ippatsu_eligible);

    refreshTurnInfo();
    displayAllMelds(initialMelds);
    renderAgariTiles((initialAgariTiles && initialAgariTiles[0]) ? initialAgariTiles[0] : []);
    if (gamePhase === 'call_wait' && initialPendingCalls.length > 0) {
      renderAvailableCalls(initialPendingCalls, initialLastDiscarded);
    }

    // åˆæœŸæ¨ã¦ç‰Œã‚’è¡¨ç¤º
    for (let p = 0; p < discards.length; ++p) {
      renderDiscards(p);
    }
  </script>
</body>
</html>